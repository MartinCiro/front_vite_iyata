import{G as y,E as L,y as u}from"./index-VqPlM1MX.js";const l=new Map;let j=2e3;function x(){return j++}class O{async getTasks(a=null){try{let n=(await y.get("/todos")).data.slice(0,20).map(o=>{const k=l.get(o.id);return k||{id:o.id,title:o.title,description:`Task: ${o.title}`,status:o.completed?"done":"todo",priority:"medium",due_date:new Date(Date.now()+10080*60*1e3).toISOString(),project_id:1,created_at:new Date().toISOString(),user_id:1}});const g=[...Array.from(l.values()).filter(o=>o.id>=2e3).filter(o=>!n.some(k=>k.id===o.id)),...n];return a?g.filter(o=>o.project_id==a):g.sort((o,k)=>k.id-o.id)}catch(e){throw e}}async getTask(a){try{const e=l.get(parseInt(a));if(e)return e;const n=(await y.get(`/todos/${a}`)).data;return{id:n.id,title:n.title,description:`Task: ${n.title}`,status:n.completed?"done":"todo",priority:"medium",due_date:new Date(Date.now()+10080*60*1e3).toISOString(),project_id:1,created_at:new Date().toISOString(),user_id:1}}catch(e){throw e}}async createTask(a){try{const i={id:x(),title:a.title,description:a.description||"",status:a.status||"todo",priority:a.priority||"medium",due_date:a.due_date||new Date(Date.now()+10080*60*1e3).toISOString(),project_id:a.project_id||1,created_at:new Date().toISOString(),user_id:1};return l.set(i.id,i),i}catch(e){throw e}}async updateTask(a,e){try{const i=parseInt(a);if(i>=2e3){const n=l.get(i);if(!n)throw new Error(`Task with ID ${i} not found in memory`);const T={...n,...e,id:i};return l.set(i,T),T}else{await y.put(`/todos/${a}`,{title:e.title,completed:e.status==="done",userId:1});const n={id:i,title:e.title,description:e.description||"",status:e.status||"todo",priority:e.priority||"medium",due_date:e.due_date||existingTask?.due_date||new Date(Date.now()+10080*60*1e3).toISOString(),project_id:e.project_id||1,created_at:existingTask?.created_at||new Date().toISOString(),user_id:1};return l.set(i,n),n}}catch(i){throw i}}async deleteTask(a){try{const e=parseInt(a);return e>=2e3||await y.delete(`/todos/${a}`),l.delete(e),{success:!0}}catch(e){throw e}}}const p=new O;function v(){const t=L({tasks:[],currentTask:null,isLoading:!1,error:null}),a=async(r=null)=>{t.isLoading=!0,t.error=null;try{t.tasks=await p.getTasks(r)}catch(s){throw t.error=s.message,s}finally{t.isLoading=!1}},e=async r=>{t.isLoading=!0,t.error=null;try{t.currentTask=await p.getTask(r)}catch(s){throw t.error=s.message,s}finally{t.isLoading=!1}},i=async r=>{t.isLoading=!0,t.error=null;try{const s=await p.createTask(r);return t.tasks.unshift(s),s}catch(s){throw t.error=s.message,s}finally{t.isLoading=!1}},n=async(r,s)=>{t.isLoading=!0,t.error=null;try{const d=parseInt(r),c=t.tasks.find(m=>m.id===d);if(!c)throw new Error("Task not found");const f={title:c.title,description:c.description,status:s,priority:c.priority,due_date:c.due_date,project_id:c.project_id,created_at:c.created_at},w=await p.updateTask(r,f),h=t.tasks.findIndex(m=>m.id===d);return h!==-1&&(t.tasks[h]=w),t.currentTask?.id===d&&(t.currentTask=w),w}catch(d){throw t.error=d.message,d}finally{t.isLoading=!1}},T=async r=>{t.isLoading=!0,t.error=null;try{await p.deleteTask(r),t.tasks=t.tasks.filter(s=>s.id!==parseInt(r)),t.currentTask?.id===parseInt(r)&&(t.currentTask=null)}catch(s){throw t.error=s.message,s}finally{t.isLoading=!1}},g=async(r,s)=>{t.isLoading=!0,t.error=null;try{const d=await p.updateTask(r,s),c=t.tasks.findIndex(f=>f.id===parseInt(r));return c!==-1&&(t.tasks[c]=d),t.currentTask?.id===parseInt(r)&&(t.currentTask=d),d}catch(d){throw t.error=d.message,d}finally{t.isLoading=!1}},o=u(()=>t.tasks.filter(r=>r.status==="pending")),k=u(()=>t.tasks.filter(r=>r.status==="in-progress")),_=u(()=>t.tasks.filter(r=>r.status==="completed")),I=u(()=>t.tasks.filter(r=>r.priority==="high")),S=r=>u(()=>t.tasks.filter(s=>s.project_id==r));return{tasks:u(()=>t.tasks),currentTask:u(()=>t.currentTask),isLoading:u(()=>t.isLoading),error:u(()=>t.error),pendingTasks:o,inProgressTasks:k,completedTasks:_,highPriorityTasks:I,tasksByProject:S,fetchTasks:a,fetchTask:e,createTask:i,updateTask:g,deleteTask:T,updateTaskStatus:n}}export{v as u};
